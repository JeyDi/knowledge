- Gainlo
  - [x] [Longest Increasing Subarray](http://blog.gainlo.co/index.php/2017/02/02/uber-interview-questions-longest-increasing-subarray/)
  - [x] [Arrange Given Numbers To Form The Biggest Number Possible](http://blog.gainlo.co/index.php/2017/01/20/arrange-given-numbers-to-form-the-biggest-number-possible/)
  - [x] [Search an Element in a Sorted and Rotated Array](http://blog.gainlo.co/index.php/2017/01/12/rotated-array-binary-search/)
  - [x] [Permutations of an Array of Arrays](http://blog.gainlo.co/index.php/2017/01/05/uber-interview-questions-permutations-array-arrays/)
  - [x] [Permutations of Parentheses](http://blog.gainlo.co/index.php/2016/12/23/uber-interview-questions-permutations-parentheses/)
  - [x] [Maximum Sum of Non-adjacent Elements](http://blog.gainlo.co/index.php/2016/12/02/uber-interview-question-maximum-sum-non-adjacent-elements/)
  - [x] [Move Zeroes](http://blog.gainlo.co/index.php/2016/11/18/uber-interview-question-move-zeroes/)
  - [x] [Weighted Random Numbers](http://blog.gainlo.co/index.php/2016/11/11/uber-interview-question-weighted-random-numbers/)
  - [x] [Delimiter Matching](http://blog.gainlo.co/index.php/2016/09/30/uber-interview-question-delimiter-matching/)
  - [x] [Map Implementation](http://blog.gainlo.co/index.php/2016/08/14/uber-interview-question-map-implementation/)
  - [x] [Duplicate Elements of An Array](http://blog.gainlo.co/index.php/2016/05/10/duplicate-elements-of-an-array/)
  - [x] [Group Anagrams](http://blog.gainlo.co/index.php/2016/05/06/group-anagrams/)
  - [x] [Deepest Node In a Tree](http://blog.gainlo.co/index.php/2016/04/26/deepest-node-in-a-tree/)
  - [x] [Longest Substring Without Repeating Characters](http://blog.gainlo.co/index.php/2016/10/07/facebook-interview-longest-substring-without-repeating-characters/)
  - [x] [3sum](http://blog.gainlo.co/index.php/2016/07/19/3sum/)
  - [x] [Meeting Room Scheduling Problem](http://blog.gainlo.co/index.php/2016/07/12/meeting-room-scheduling-problem/)
  - [x] [Lowest Common Ancestor](http://blog.gainlo.co/index.php/2016/07/06/lowest-common-ancestor/)
  - [x] [Flatten a Linked List](http://blog.gainlo.co/index.php/2016/06/12/flatten-a-linked-list/)
  - [x] [Second Largest Element of a Binary Search Tree](http://blog.gainlo.co/index.php/2016/06/03/second-largest-element-of-a-binary-search-tree/)
  - [x] [Subarray With Given Sum](http://blog.gainlo.co/index.php/2016/06/01/subarray-with-given-sum/)
  - [x] [Minimum Number of Deletions Of a String](http://blog.gainlo.co/index.php/2016/04/29/minimum-number-of-deletions-of-a-string/)
  - [x] [Print All Paths Of a Binary Tree](http://blog.gainlo.co/index.php/2016/04/15/print-all-paths-of-a-binary-tree/)
  - [x] [Find The Longest Substring With K Unique Characters](http://blog.gainlo.co/index.php/2016/04/12/find-the-longest-substring-with-k-unique-characters/)
  - [x] [If a String Contains an Anagram of Another String](http://blog.gainlo.co/index.php/2016/04/08/if-a-string-contains-an-anagram-of-another-string/)
- CoderCareer
  - [x] http://codercareer.blogspot.it/2011/09/interview-question-no-1-binary-search.html?m=1
  - [x] http://codercareer.blogspot.it/2011/09/no-02-stack-with-function-min.html?m=1
  - [x] http://codercareer.blogspot.it/2011/09/no-03-maximum-sum-of-all-sub-arrays.html?m=1
  - [x] http://codercareer.blogspot.it/2011/09/no-04-paths-with-specified-sum-in.html?m=1
  - [x] http://codercareer.blogspot.it/2011/09/no-05-least-k-numbers.html?m=1
  - [x] http://codercareer.blogspot.it/2011/09/no-06-post-order-traversal-sequences-of.html?m=1
  - [x] http://codercareer.blogspot.it/2011/09/no-07-reverse-words-in-sentence.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-08-calculate-12n.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-09-numbers-with-given-sum.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-10-k-th-node-from-end.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-11-print-binary-trees-from-top-to.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-12-mirror-of-binary-trees.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-13-first-character-appearing-only.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-14-last-number-in-circle.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-15-fibonacci-sequences.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-16-maximum-length-of-incremental.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-17-queue-implemented-with-two-stacks.html?m=1
  - [x] http://codercareer.blogspot.it/2011/10/no-18-reverse-linked-list.html?m=1
  - [x] http://codercareer.blogspot.it/2011/11/no-19-left-rotation-of-string.html?m=1
  - [x] http://codercareer.blogspot.it/2011/11/no-20-number-of-1-in-binary.html?m=1
  - [x] http://codercareer.blogspot.it/2011/11/no-21-push-and-pop-sequences-of-stacks.html?m=1
  - [x] http://codercareer.blogspot.it/2011/11/no-22-turning-number-in-array.html?m=1
  - [x] http://codercareer.blogspot.it/2011/11/no-23-palindrome-numbers.html?m=1
  - [x] http://codercareer.blogspot.it/2011/11/no-24-intersection-of-sorted-arrays.html?m=1
  - [x] http://codercareer.blogspot.it/2011/12/no-25-edit-distance.html?m=1
  - [x] http://codercareer.blogspot.it/2011/12/no-26-minimal-number-of-coins-for.html?m=1
  - [x] http://codercareer.blogspot.it/2011/12/no-27-area-of-rectangles.html?m=1
  - [x] http://codercareer.blogspot.it/2011/12/no-28-pair-with-maximal-difference.html?m=1
  - [x] http://codercareer.blogspot.it/2012/01/no-29-loop-in-list.html?m=1
  - [x] http://codercareer.blogspot.it/2012/01/no-30-median-in-stream.html?m=1
  - [x] http://codercareer.blogspot.it/2012/01/no-31-binary-search-tree-verification.html?m=1
  - [x] http://codercareer.blogspot.it/2012/02/no-32-remove-numbers-in-array.html?m=1
  - [x] http://codercareer.blogspot.it/2012/02/no-33-maximums-in-sliding-windows.html?m=1
  - [x] http://codercareer.blogspot.it/2012/02/no-34-string-path-in-matrix.html?m=1
  - [x] http://codercareer.blogspot.it/2013/01/no-35-depth-of-binary-trees.html?m=1
  - [x] http://codercareer.blogspot.it/2013/02/no-36-permutation.html?m=1
  - [x] http://codercareer.blogspot.it/2013/02/no-37-missing-number-in-array.html?m=1
  - [x] http://codercareer.blogspot.it/2013/02/no-38-digits-in-sequence.html?m=1
  - [x] http://codercareer.blogspot.it/2013/02/no-39-stacks-sharing-array.html?m=1
  - [x] http://codercareer.blogspot.it/2013/02/no-40-add-on-lists.html?m=1
  - [x] http://codercareer.blogspot.it/2013/02/no-41-group-of-1s-in-matrix.html?m=1
  - [x] http://codercareer.blogspot.it/2013/02/no-42-three-increasing-elements-in-array.html?m=1
  - [ ] http://codercareer.blogspot.it/2013/02/no-43-minimal-number-of-splits-on-string.html?m=1
  - [ ] http://codercareer.blogspot.it/2013/02/no-44-maximal-stolen-values.html?m=1
  - [x] http://codercareer.blogspot.it/2013/03/no-45-closest-node-in-binary-search-tree_2.html?m=1
  - [x] http://codercareer.blogspot.it/2013/03/no-46-nodes-with-sum-in-binary-search.html?m=1
  - [x] http://codercareer.blogspot.it/2013/03/no-47-search-in-rotation-of-array_31.html?m=1
  - [x] http://codercareer.blogspot.it/2013/11/no-48-least-number-after-deleting-digits.html?m=1
  - [ ] http://codercareer.blogspot.it/2013/11/no-49-longest-substring-without.html?m=1
  - [x] http://codercareer.blogspot.it/2013/12/no-50-numbers-appearing-once.html?m=1
  - [x] http://codercareer.blogspot.it/2013/12/no-51-next-number-with-same-set-of.html?m=1
  - [ ] http://codercareer.blogspot.it/2013/12/no-52-maximal-product-when-cutting-rope.html?m=1
  - [ ] http://codercareer.blogspot.it/2014/03/no-53-longest-arithmetic-sequence.html?m=1
  - [ ] http://codercareer.blogspot.it/2014/08/no-54-merge-ranges.html?m=1
  - [x] http://codercareer.blogspot.it/2014/09/no-55-translating-numbers-to-string.html?m=1
  - [ ] http://codercareer.blogspot.it/2014/10/no-56-maximal-value-of-gifts.html?m=1
  - [x] http://codercareer.blogspot.it/2014/10/no-57-integer-identical-to-index.html?m=1
  - [x] http://codercareer.blogspot.it/2015/09/no-58-search-in-adjacent-numbers.html?m=1
  - [x] http://codercareer.blogspot.it/2016/04/no-59-duplications-in-arrays.html?m=1
- Custom
  - [x] [2-sum](https://stackoverflow.com/questions/11928091/linear-time-algorithm-for-2-sum)

## Coding exercises/challenges

Once you've learned your brains out, put those brains to work.
Take coding challenges every day, as many as you can.

- [x] [How to Find a Solution](https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-find-a-solution/)
- [x] [How to Dissect a Topcoder Problem Statement](https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-dissect-a-topcoder-problem-statement/)

Challenge sites:
- [LeetCode](https://leetcode.com/)
- [TopCoder](https://www.topcoder.com/)
- [Project Euler (math-focused)](https://projecteuler.net/index.php?section=problems)
- [Codewars](http://www.codewars.com)
- [HackerRank](https://www.hackerrank.com/)
- [Codility](https://codility.com/programmers/)
- [InterviewCake](https://www.interviewcake.com/)
- [Geeks for Geeks](http://www.geeksforgeeks.org/)
- [InterviewBit](https://www.interviewbit.com/invite/icjf)
- [Sphere Online Judge (spoj)](http://www.spoj.com/)

## Permutations of an array A

```javascript
function permute(A){
  if(!A) return;
  if(A.length <= 1) return [A];

  var permutations = this.permute(A.slice(1));
  var results = [];

  for(var i=0; i<permutations.length; i++) {
    results.push([A[0]].concat(permutations[i]));
  }

  for(var i=0; i<permutations.length; i++) {
    for(var j=1; j<A.length; j++) {
      results.push(permutations[i].slice(0, j).concat([A[0]]).concat(permutations[i].slice(j)));
    }
  }
  return results;
}
```

## 2sum (sliding window)
Given an integer x and a sorted array a of N distinct integers, design a linear-time algorithm to determine if there exists two distinct indices i and j such that a[i] + a[j] == x.

This is type of Subset sum problem. For every i there is such j that a[i]+a[j] is closest to x. All these (i,j) pairs form closest-to-x line. We just need to walk along this line and look for a[i]+a[j] == x. Complexity: O(n).

```javascript
function twosum(A, S) {
  if(!A) return [];
  
  var i = 0, j = A.length - 1;
  
  for(; i<A.length && j >= 0 && i < j; ) {
    if(A[i] + A[j] === S) {
      return [i, j];
    }
    
    if(A[i] + A[j] > S) {
      j--;
    } else {
      i++;
    }
  }
  
  return [];
}
```

## Longest Increasing subarray (sliding window)
Given an unsorted array, find the max length of subarray in which the numbers are in incremental order.
For example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subarray with the most numbers in incremental order is {1, 5, 8, 9} and the expected output is 4. Complexity O(n). Subarray is contiguous respect than a subsequence.

```javascript
function longest_increasing_subsubarray(A) {
  var lis = [];
  lis[0] = 1;
  var max = 0;
  
  for(var i=1; i < A.length; i++) {
     if(A[i-1] <= A[i]) {
       lis[i] = lis[i-1] + 1;
     } else {
       lis[i] = 1;
     }
     if(max < lis[i]) {
       max = lis[i];
     }
  }
  
  console.log(lis);
  return max;
}
```

## Longest Increasing subsequence
Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.
For example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5. Complexity O(n^2).

```javascript
function longest_increasing_subsequence(A) {
   var ml = [];
   ml[0] = 1;
   for(var i = 1; i<A.length; i++) {
       var max = 0;
       for(var j=0; j<i; j++) {
            if(A[i] > A[j] && ml[j] > max) {
              max = ml[j];
            }
       }
       if(ml[i-1] > max + 1) {
         ml[i] = ml[i-1];
       } else {
         ml[i] = max + 1;
       }
   }
   return ml[A.length-1];
}
```

## Search an Element in a Sorted and Rotated Array
Search an element in a sorted and rotated array, e.g. [10, 20, 1, 3, 6, 7, 8].

```javascript
function binary_search(A, x) {
  if(A.length === 0) return;
  if(A.length === 1) return A[0] === x ? 0 : -1;
  
  var mid = Math.ceil(A.length/2) - 1;
  var high = A.length-1;
  var low = 0;
  
  if(A[mid] === x) {
    return mid;
  } else if(A[mid] > x){
    if(A[low] < A[mid]) {
      var result = binary_search(A.slice(mid+1), x);
      return result !== -1 ? mid + 1 + result : undefined;
    } else {
      return binary_search(A.slice(0, mid), x);
    }
  } else {
    if(A[high] < x) {
      return binary_search(A.slice(0, mid), x);
    } else {
      var result = binary_search(A.slice(mid+1), x);
      return result !== -1 ? mid + 1 + result : -1;
    }
  }
}
```

## Intersection of Sorted Arrays
Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.

For example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}. 

Solution 1: Complexity O(m+n)

```javascript
function intersection(A, B) {

  if(!A || !B) return;

  var result = [];

  for(var i=0, j=0; i<A.length && j < B.length; ) {

    if(A[i] === B[j]) {

      result.push(A[i]);

      i++;

      j++;

    } else if(A[i] < B[j]) {
       i++;

    } else {

       j++;

    }

 }
 return result;
}
```

Solution 2: for m >> n, complexity O(nlogm), for each number of A we use binary_search on B.
